---
description: 
globs: 
alwaysApply: false
---
Diagnose and resolve the issue described above using a systematic, validation-driven approach:

1. **Collect Precise Context**:

   - Gather all relevant details: error messages, logs, stack traces, and observed behaviors tied to the issue.
Diagnose and resolve the issue described above using a systematic, validation-driven approach:

1. **Map System Context**:
   - Pinpoint affected files and dependencies using `grep_search` for exact terms (e.g., function names) or `codebase_search` for broader context.
   - Trace the data flow or execution path to define the issue's boundaries—map inputs, outputs, and interactions.
   - Verify the issue's location within the Hexagonal Architecture layers (domain, application, infrastructure, ui, shared).

2. **Investigate Root Causes**:
   - List at least three plausible causes, spanning code logic, dependencies, or configuration—e.g., "undefined variable," "missing import," "API timeout."
   - Validate each using `cat -n <file path>` to inspect code with line numbers and `tree -L 4 --gitignore | cat` to check related files.
   - Confirm or rule out hypotheses by cross-referencing execution paths and dependency chains.
   - Check API response structure: `{ success, data, message, code, status }`.

3. **Reuse Existing Patterns**:
   - Search the codebase with `codebase_search` for prior fixes or similar issues already addressed.
   - Identify reusable utilities or error-handling strategies that align with project conventions—avoid reinventing solutions.
   - Check `shared/` directory for common error handling patterns.
   - Validate reuse candidates against the current issue's specifics to ensure relevance.

4. **Analyze Impact**:
   - Trace all affected dependencies (e.g., imports, calls, external services) to assess the issue's scope.
   - Determine if it's a localized bug or a symptom of a broader design flaw—e.g., "tight coupling" or "missing error handling."
   - Highlight potential side effects of both the issue and proposed fixes on performance or maintainability.
   - Consider impact on accessibility (WCAG2) and internationalization.

5. **Propose Targeted Fixes**:
   - Suggest specific, minimal changes—provide file paths (relative to workspace root), line numbers, and code snippets.
   - Justify each fix with clear reasoning, linking it to stability, reusability, or system alignment—e.g., "Adding a null check prevents crashes."
   - Ensure fixes follow project conventions:
     * Components: PascalCase
     * Hooks: `use` + camelCase
     * Utilities: camelCase
     * Constants: UPPER_SNAKE_CASE
   - Avoid broad refactoring unless explicitly requested; focus on resolving the issue efficiently.

6. **Validate and Monitor**:
   - Outline test cases—normal, edge, and failure scenarios—to verify the fix (e.g., "Test with empty input").
   - Use Jest & Testing Library for unit tests, Cypress for E2E tests.
   - Follow test patterns:
     * Use `I18nextProvider` and `MemoryRouter` for integration
     * Mock only what is necessary
     * For route tests, mock layouts with `<Outlet />`
   - Ensure 90%+ test coverage for modified code.
   - Suggest adding a log or metric (e.g., "Log error X at line Y") to track recurrence and confirm resolution.

This process ensures a thorough, efficient resolution that strengthens the codebase while directly addressing the reported issue.
